<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		 
			
  
    <meta name="twitter:card" content="summary"/>
    
      <meta name="twitter:image" content="https://ngc7292.github.io/images/avatar.png" />
    
  
  
  <meta name="twitter:title" content="data structures"/>
  <meta name="twitter:description" content="data structures"/>
  
    <meta name="twitter:site" content="@ngc7293"/>
  
  
  
  
    <meta name="twitter:creator" content="@ngc7293"/>
  



		
		<meta name="author" content="ngc7293">
		
		<meta name="generator" content="Hugo 0.36.1" />
		<title>data structures &middot; ngc7293&#39;s blog</title>
		<link rel="shortcut icon" href="https://ngc7292.github.io/images/favicon.ico">
		<link rel="stylesheet" href="https://ngc7292.github.io/css/style.css">
		<link rel="stylesheet" href="https://ngc7292.github.io/css/highlight.css">

		
		<link rel="stylesheet" href="https://ngc7292.github.io/css/font-awesome.min.css">
		

		
		<link href="https://ngc7292.github.io/index.xml" rel="alternate" type="application/rss+xml" title="ngc7293&#39;s blog" />
		

		

		<script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='https://ngc7292.github.io/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://ngc7292.github.io/posts'>Archive</a>
	<a href='https://ngc7292.github.io/tags'>Tags</a>
	<a href='https://ngc7292.github.io/about'>About</a>

	

	
	<a class="cta" href="https://ngc7292.github.io/index.xml">Subscribe</a>
	
</nav>


        <section id="wrapper" class="post">
            <article>
                <header>
                    <h1>
                        data structures
                    </h1>
                    <h2 class="headline">
                    Nov 16, 2018 00:00
                    · 453 words
                    · 3 minute read
                      <span class="tags">
                      
                      
                          
                              <a href="https://ngc7292.github.io/tags/data-structures">data structures</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                  
                    <div id="toc">
                      <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#基本概念">基本概念</a>
<ul>
<li><a href="#数据结构">数据结构</a></li>
<li><a href="#算法">算法</a>
<ul>
<li><a href="#时间复杂度">时间复杂度</a></li>
<li><a href="#空间复杂度">空间复杂度</a></li>
</ul></li>
</ul></li>
<li><a href="#线性表">线性表</a>
<ul>
<li><a href="#顺序表示">顺序表示</a></li>
<li><a href="#链式表示">链式表示</a>
<ul>
<li><a href="#单链表基本操作">单链表基本操作</a></li>
</ul></li>
</ul></li>
<li><a href="#栈与队列">栈与队列</a></li>
<li><a href="#树与二叉树">树与二叉树</a>
<ul>
<li><a href="#树">树</a></li>
<li><a href="#二叉树及其遍历-线索二叉树">二叉树及其遍历，线索二叉树</a></li>
<li><a href="#树以及森林">树以及森林</a></li>
</ul></li>
<li><a href="#图">图</a>
<ul>
<li><a href="#存储以及基本操作">存储以及基本操作</a></li>
<li><a href="#图的便利">图的便利</a></li>
<li><a href="#图的应用">图的应用</a></li>
</ul></li>
<li><a href="#查找">查找</a>
<ul>
<li><a href="#顺序查找">顺序查找</a></li>
<li><a href="#折半查找">折半查找</a></li>
<li><a href="#分块查找">分块查找</a></li>
<li><a href="#b树与b-树">B树与B-树</a></li>
<li><a href="#hash表-散列查找">HASH表（散列查找）</a></li>
</ul></li>
<li><a href="#排序">排序</a>
<ul>
<li><a href="#冒泡排序">冒泡排序</a></li>
<li><a href="#插入排序">插入排序</a></li>
<li><a href="#选择排序">选择排序</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
                    </div>
                  
                
                <section id="post-body">
                    <p></p>

<h2 id="基本概念">基本概念</h2>

<h3 id="数据结构">数据结构</h3>

<p>数据结构的三个要素：逻辑结构，存储结构，以及数据的运算</p>

<p>数据的逻辑结构可以分为线性结构以及非线性结构</p>

<p>线性结构可以继续分为一般线性表，受限线性表（栈和队列，串），线性表推广（数组，广义表），</p>

<p>非线性结构可以分为集合，树形结构（一般树，二叉树），图形结构（有向图，无向图）。</p>

<p>数据的存储结构可以分为顺序存储，链式存储，索引存储，散列存储</p>

<p>顺序存储：将所有逻辑上相邻的元素存储在物理位置也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现，其优点是可以实现随机存储，但是缺点是指可以使用相邻的存储单元，可能产生较多的外部碎片。</p>

<p>链式存储：借助指示元素存储地址的指针表示元素之间的逻辑关系，其优点不会产生外部碎片，但是每个元素因为存储指针而占用额外的空间，并且只可以实现顺序存储。</p>

<p>索引存储：存储信息外还建立附加的索引表，每一个索引项包括（关键字，地址）优点是检索速度快，缺点是增加了附加的索引表，会占用较多的存储空间，在增加以及删除时需要修改索引表，因此会花费很长时间。</p>

<p>散列存储：根据元素的关键字计算元素的存储位置，又称HASH存储，优点：检索，增加，删除等操作都很快，缺点是若hash函数不好可能出现元素存储单元的冲突，解决冲突会增加时间以及空间的开销。</p>

<p>可以用抽象数据类型来表示一个完整的数据结构。</p>

<h3 id="算法">算法</h3>

<p>算法的特性：有穷性，确定性，可行性，输入以及输出</p>

<p>效率的度量：时间复杂度以及空间复杂度</p>

<h4 id="时间复杂度">时间复杂度</h4>

<p>一个语句被重复执行的次数成为语句的频度，算法中所有语句的频度之和计为$T(x)$，它是该算法问题规模$n$的函数，时间复杂度主要来分析$T(n)$的数量级，算法运算中的基本运算（最深层循环的语句）的频度与$T(n)$同数量级，所以采用算法中的基本频度$f(n)$，来分析算法的时间复杂度，因此时间复杂度记为
$$
T(n)=O(f(n))
$$
上式中$O$为$T(n)$的数量级</p>

<p>在算法中，时间复杂度不仅取决于问题的规模，也取决于输入数据的性质</p>

<p>最坏时间复杂度：是指在最坏的情况下，算法的是时间复杂度</p>

<p>平均时间复杂度：指的是在所有可能的输入实例下的等概率出现的情况下算法的期望执行时间。</p>

<p>最好时间复杂度：最好的情况下，算法的时间复杂度。</p>

<p>加法规则：
$$
T(n) = T1(n)+T2(n) = O(f(n))+O(g(n)) = O(max(f(n),g(n)))
$$</p>

<p>乘法规则：
$$
T(n) = T1(n)*T2(n) = O(f(n))*O(g(n)) = O(f(n)*g(n))
$$</p>

<p>渐进的时间复杂度：
$$
O(1) &lt; O(log_2n) &lt; O(n) &lt; O(nlog_2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)
&lt;O(n^n)
$$</p>

<h4 id="空间复杂度">空间复杂度</h4>

<p>定义为该算法所耗费的存储空间，是问题规模n的函数，只分析除输入以及程序以外的额外空间。</p>

<h2 id="线性表">线性表</h2>

<p>线性表是具有*相同数据类型*的数据元素的*有限序列*，除第一个元素外，每个元素有且仅有一个直接前驱，除最后一个元素外，每个元素都有且仅有一个直接后驱。</p>

<p>线性表的特点：表中元素个数有限，具有逻辑上的顺序性，序列中各个元素排序有其先后顺序，表中元素为数据元素，且都是单个元素，表中元素的数据类型都相同，表中元素具有抽象性，即仅考虑元素间的逻辑关系。</p>

<h3 id="顺序表示">顺序表示</h3>

<p>线性表的顺序存储又被称为顺序表，其用一组地址连续的存储单元来一次存储数据元素，在逻辑上相邻的两个元素在物理上也相邻。</p>

<p>顺序存储的类型表述：</p>

<pre><code class="language-c++">#define Maxsize 20

typedef int ElemType;

typedef struct lnode
{
	ElemType data[MAXSIZE];
	int length;
}sqlist;

</code></pre>

<p>线性表的顺序存储可以是静态分配也可以动态分配，在程序执行过程中，也可以进行动态分配。其最主要的特点是随机访问，通过首地址以及元素序号可以在$O(1)$的时间内找到指定的元素。存储密度高，每个结点只存储数据元素。逻辑上相邻的元素在物理上也相邻，所以在插入以及删除需要移动大量元素。</p>

<p>顺序存储的插入操作：</p>

<pre><code class="language-c++">Status ListInsert(sqlist *L,int i,ElemType e)
{
	int k;
	if (L-&gt;length == MAXSIZE)return ERROR;
	if (i &lt; 1 || i &gt; L-&gt;length + 1)return ERROR;
	if (i &lt;= L-&gt;length)
	{
		for (k = L-&gt;length - 1; k &gt;= i-1; k--)
		{
			L-&gt;data[k + 1] = L-&gt;data[k];
		}
	}
	L-&gt;data[i - 1] = e;
	L-&gt;length++;
	return OK;
}
</code></pre>

<p>最好情况：在表尾插入，时间复杂度$O(1)$</p>

<p>最坏情况：在表头插入，时间复杂度$O(n)$</p>

<p>平均情况：假设$p<em>i$是在第i个位置上插入的概率，则在长度为n的线性表插入节点所需要移动的平均次数为
$$
\Sigma</em>{i=1}^{n+1}p_i(n-i+1)=n/2
$$
因此，插入算法的平均时间复杂度为$O(n)$</p>

<p>顺序存储的删除操作：</p>

<pre><code class="language-c++">Status ListDelete(sqlist *L, int i, ElemType *e)
{
	int k;
	if (L-&gt;length == 0)return ERROR;
	if (i &lt; 1 || i &gt;= L-&gt;length) return ERROR;
	*e = L-&gt;data[i - 1];
	if (i &lt; L-&gt;length)
	{
		for (k = i; k &lt;= L-&gt;length; k++)
		{
			L-&gt;data[k - 1] = L-&gt;data[k];
		}
	}
	L-&gt;length--;
	return OK;
}
</code></pre>

<p>最好情况：在表尾删除，时间复杂度$O(1)$</p>

<p>最坏情况：在表头删除，时间复杂度$O(n)$</p>

<p>平均情况：假设$p<em>i$是在第i个位置上删除的概率，则在长度为n的线性表删除节点所需要移动的平均次数为
$$
\Sigma</em>{i=1}^{n}p_i(n-i)=n/2
$$
因此，插入算法的平均时间复杂度为$O(n)$</p>

<p>线性存储的顺序查找：</p>

<pre><code class="language-c++">int LocateElem(sqlist L, ElemType e)
{
	int i;
	if (L.length == 0)
	{
		return 0;
	}
	for (i = 0; i &lt;= L.length; i++)
	{
		if (L.data[i] == e)
			break;
	}
	if (i &gt;= L.length)
		return 0;
	return i + 1;
}
</code></pre>

<p>最好情况：在表头找到，仅需比较一次，时间复杂度$O(1)$</p>

<p>最坏情况：在表尾找到，时间复杂度$O(n)$</p>

<p>平均情况：假设$p<em>i$是在第i个位置上查找的概率，则在长度为n的线性表查找节点所需要比较的平均次数为
$$
\Sigma</em>{i=1}^{n}p_i*i=(n+1)/2
$$
因此，插入算法的平均时间复杂度为$O(n)$</p>

<h3 id="链式表示">链式表示</h3>

<p>单链表的链式存储又称单链表，是指通过一组任意的存储单元存储线性表的信息。</p>

<p>对于每个链表节点，不仅要存储自身还要存放一个指向后继的指针。</p>

<pre><code class="language-c++">typedef struct Node
{
	ElemType data;
	struct Node *next;
}Node;
</code></pre>

<p>单链表解决的关于线性表需要大量连续空间的问题，但是需要附加指针域，所以十分浪费空间。</p>

<p>通常我们用一个头指针来标示一个单链表，另外，为了操作方便，一般在单链表的头节点数据域不设信息，或者记录表长等。</p>

<p>1.无论链表是否为空，头指针都是指向头结点的指针</p>

<p>2.开始节点的位置被存放在头节点中</p>

<h4 id="单链表基本操作">单链表基本操作</h4>

<p>单链表的建立可以通过头插法或者尾插法来实现，头插法是从一个空表开始，将读取到的信息存放在新的结点的数据域上，然后将新节点插入到当前链表的表头即头节点后，其时间复杂度为$O(n)$，但是其读入数据与生成的链表中的元素的顺序是相反的，尾插法及将新结点插入到当前链表的表尾，所以需要增加一个尾指针使其始终指向当前列表的尾结点</p>

<p>头插法创建新链表</p>

<pre><code class="language-c++">LinkList *CreateListHead(LinkList *L, int n)
{
	LinkList p;
	int i;
	srand(23);
	(*L)-&gt;next = NULL;
	for (i = 0; i &lt; n; i++)
	{
		p = (LinkList)malloc(sizeof(Node));
		p-&gt;data = rand() % 100 + 1;
		p-&gt;next = (*L)-&gt;next;
		(*L)-&gt;next = p;
	}
	return L;
}
</code></pre>

<p>尾插法创建新链表</p>

<pre><code class="language-c++">LinkList *CreateListTail(LinkList *L, int n)
{
	LinkList p,r;
	int i;
	srand(23);
	*L = (LinkList)malloc(sizeof(Node));
	r = *L;
	for (i = 0; i &lt; n; i++)
	{
		p = (LinkList)malloc(sizeof(Node));
		p-&gt;data = rand() % 100 + 1;
		r-&gt;next = p;
		r = p;
	}
	r-&gt;next = NULL;
	return L;
}
</code></pre>

<p>单链表的查询从第一个结点开始顺指针next域向下查询，按序号或者按值查询的是时间复杂度均为$O(n)$</p>

<pre><code class="language-c++">Status GetElemFromNode(LinkList L, int i,ElemType *e)
{
	int j;
	LinkList p;
	p = L-&gt;next;
	j = 1;
	while (p&amp;&amp;j &lt; i)
	{
		p = p-&gt;next;
		++j;
	}
	if (!p || j &gt; i)
	{
		return ERROR;
	}
	*e = p-&gt;data;
	return OK;
}
</code></pre>

<h2 id="栈与队列">栈与队列</h2>

<h2 id="树与二叉树">树与二叉树</h2>

<h3 id="树">树</h3>

<h3 id="二叉树及其遍历-线索二叉树">二叉树及其遍历，线索二叉树</h3>

<h3 id="树以及森林">树以及森林</h3>

<h2 id="图">图</h2>

<h3 id="存储以及基本操作">存储以及基本操作</h3>

<h3 id="图的便利">图的便利</h3>

<h3 id="图的应用">图的应用</h3>

<h2 id="查找">查找</h2>

<h3 id="顺序查找">顺序查找</h3>

<h3 id="折半查找">折半查找</h3>

<h3 id="分块查找">分块查找</h3>

<h3 id="b树与b-树">B树与B-树</h3>

<h3 id="hash表-散列查找">HASH表（散列查找）</h3>

<h2 id="排序">排序</h2>

<h3 id="冒泡排序">冒泡排序</h3>

<p>算法实现：</p>

<pre><code>1. 比较相邻元素，并排序

2. 对每一个相邻元素进行操作

3. 对所有元素重复操作，知道最后一个

4. 重复1～3，使排序完成。
</code></pre>

<p>其最佳时间复杂度为$O(n)$，即所有元素都为正序，其最坏时间复杂度为$O(n^2)$，即所有元素都需要排序，平均时间复杂度为$O(n^2)$。</p>

<p>改进：设置pos，记录每次交换的最后次序。</p>

<h3 id="插入排序">插入排序</h3>

<p>算法实现：</p>

<pre><code>1. 取出元素，并在已经排序的字符串中进行扫描
2. 插入元素
3. 重复1～2
</code></pre>

<p>其最佳时间复杂度为$O(n)$，即所有元素为正序，最坏时间复杂度为$O(n^2)$，所有元素都为倒序，平均复杂度为$O(n^2)$</p>

<p>改进：在查找时，使用二分查找，可以大大提高插入效率。</p>

<h3 id="选择排序">选择排序</h3>
                </section>
            </article>

            
                <a class="twitter" href="https://twitter.com/intent/tweet?text=https%3a%2f%2fngc7292.github.io%2fposts%2fdata_structures%2f - %e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%a4%8d%e4%b9%a0 by @ngc7293"><span class="icon-twitter"> tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>

            

            
                <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'ngc7293s-blog'; 

     
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'https://ngc7293s-blog.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
            

            

            <footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="https://www.facebook.com/">
        <i class="fa fa-facebook-square"></i>
    </a>
    
    <a class="symbol" href="https://www.github.com/ngc7292">
        <i class="fa fa-github-square"></i>
    </a>
    
    <a class="symbol" href="https://www.twitter.com/">
        <i class="fa fa-twitter-square"></i>
    </a>
    


</div>

    
    <p class="small">
    
       © Copyright 2020 <i class="fa fa-heart" aria-hidden="true"></i> ngc7293
    
    </p>
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>

        </section>

        <script src="https://ngc7292.github.io/js/jquery-2.2.4.min.js"></script>
<script src="https://ngc7292.github.io/js/main.js"></script>
<script src="https://ngc7292.github.io/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>




  
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'ngc7293', 'auto');
ga('send', 'pageview');
</script>





    </body>
</html>
