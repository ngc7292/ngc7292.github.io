<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<meta content="summary" name="twitter:card"/>
<meta content="https://ngc7292.github.io/images/avatar.png" name="twitter:image"/>
<meta content="图与树的算法复习" name="twitter:title"/>
<meta content="图与树的算法集合" name="twitter:description"/>
<meta content="@ngc7293" name="twitter:site"/>
<meta content="@ngc7293" name="twitter:creator"/>
<meta content="ngc7293" name="author"/>
<meta content="Hugo 0.36.1" name="generator"/>
<title>图与树的算法复习 · ngc7293's blog</title>
<link href="https://ngc7292.github.io/images/favicon.ico" rel="shortcut icon"/>
<link href="https://ngc7292.github.io/css/style.css" rel="stylesheet"/>
<link href="https://ngc7292.github.io/css/highlight.css" rel="stylesheet"/>
<link href="https://ngc7292.github.io/css/font-awesome.min.css" rel="stylesheet"/>
<link href="https://ngc7292.github.io/index.xml" rel="alternate" title="ngc7293's blog" type="application/rss+xml"/>
<script async="" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
  MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
  });
  MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });

  MathJax.Hub.Config({
  
  TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
</script>
<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>
</head>
<body>
<nav class="main-nav">
<a href="https://ngc7292.github.io/"> <span class="arrow">←</span>Home</a>
<a href="https://ngc7292.github.io/posts">Archive</a>
<a href="https://ngc7292.github.io/tags">Tags</a>
<a href="https://ngc7292.github.io/about">About</a>
<a class="cta" href="https://ngc7292.github.io/index.xml">Subscribe</a>
</nav>
<section class="post" id="wrapper">
<article>
<header>
<h1>
                        图与树的算法复习
                    </h1>
<h2 class="headline">
                    Apr 27, 2020 00:00
                    · 1055 words
                    · 5 minute read
                      <span class="tags">
</span>
</h2>
</header>
<div id="toc">
<nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#树的基本算法">树的基本算法</a>
<ul>
<li>
<ul>
<li><a href="#遍历">遍历</a></li>
<li><a href="#遍历推导">遍历推导</a></li>
<li><a href="#avl-平衡二叉树">AVL （平衡二叉树）</a></li>
<li><a href="#bst-二叉搜索树">BST（二叉搜索树）</a></li>
</ul></li>
</ul></li>
<li><a href="#图的基本算法">图的基本算法</a>
<ul>
<li>
<ul>
<li><a href="#保存方式">保存方式</a></li>
<li><a href="#基本算法">基本算法</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>
</div>
<section id="post-body">
<p>部分树与图的算法回顾</p>
<p></p>
<h2 id="树的基本算法">树的基本算法</h2>
<h4 id="遍历">遍历</h4>
<p>先序遍历，后序遍历，层次遍历（递归，非递归方法）</p>
<h4 id="遍历推导">遍历推导</h4>
<p>先序+中序恢复树</p>
<p>可以采用递归的方法，先序中第一个就是root节点，然后去中序遍历中寻找该节点，该节点之前的即为左子树，该节点之后的为右子树，由此可以重新建立一个完全的二叉树</p>
<p>eg. leetcode105. Construct Binary Tree from Preorder and Inorder Traversal</p>
<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p><strong>Note:</strong>
You may assume that duplicates do not exist in the tree.</p>
<p>For example, given</p>
<pre><code>preorder = [3,9,20,15,7]
inorder = [9,3,15,20,7]
</code></pre>
<p>Return the following binary tree:</p>
<pre><code class="language-out">    3
   / \
  9  20
    /  \
   15   7
</code></pre>
<p>solution</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;stack&gt;
#include &lt;pthread.h&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;
#include &lt;cmath&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {
        return help(preorder,inorder,0,0,int(preorder.size()-1));
    }

    TreeNode* help(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder,int root,int start,int end){
        if(start &gt; end) return nullptr;
        int i = start;
        while(i &lt; end &amp;&amp; inorder[i] != preorder[root]) i++;
        TreeNode* root_node = new TreeNode(preorder[root]);
        root_node-&gt;left = help(preorder,inorder,root+1,start,i-1);
        root_node-&gt;right = help(preorder,inorder,root+1+i-start,i+1,end);
        return root_node;
    }
};

int main(){

    vector&lt;int&gt; preorder = {3,9,20,15,7};
    vector&lt;int&gt; inorder = {9,3,15,20,7};
    auto a = Solution();
    auto b = a.buildTree(preorder,inorder);
    cout&lt;&lt;1&lt;&lt;endl;
    return 0;
}
</code></pre>
<p>后序+中序恢复树</p>
<p>同先序基本一样，只是先序变为后序即可。</p>
<p>先序+中序推后序</p>
<p>参考恢复树的那个算法，如果需要推出后序排列的话，不需要重新建立新的树，在递归的时候只要递归左右子树之后直接输出跟节点即可重新建立新的后序排列。</p>
<p>eg: pat1086 Tree Traversals Again (25分)</p>
<p>An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree.</p>
<p><img alt="30" src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge81puf17wj304y03hdgh.jpg"/></p>
<p>​                                       Figure 1</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤30) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to <em>N</em>). Then 2<em>N</em> lines follow, each describes a stack operation in the format: “Push X” where X is the index of the node being pushed onto the stack; or “Pop” meaning to pop one node from the stack.</p>
<p>Output Specification:</p>
<p>For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p>
<p>Sample Input:</p>
<pre><code class="language-in">6
Push 1
Push 2
Push 3
Pop
Pop
Push 4
Pop
Pop
Push 5
Push 6
Pop
Pop
</code></pre>
<p>Sample Output:</p>
<pre><code class="language-out">3 4 2 6 5 1
</code></pre>
<p>Solution:</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;stack&gt;
#include &lt;pthread.h&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;
#include &lt;cmath&gt;

using namespace std;

vector&lt;int&gt; in,pre,post,value;

void postorder(int root, int start,int end){
    if(start &gt; end ) return;
    int i = start;
    while (i &lt; end &amp;&amp; in[i] != pre[root]) i++;
    postorder(root+1, start, i-1);
    postorder(root+1+i-start, i+1,end);
    post.push_back(value[pre[root]]);
}

vector&lt;vector&lt;int&gt;&gt; test(int a){
    vector&lt;vector&lt;int&gt;&gt; b;
    return b;
};

int main(){
    int n;
    cin&gt;&gt;n;
    string s;
    stack&lt;int&gt; st;
    int num,index=0;
    for (int j = 0; j &lt; 2*n; ++j){
        cin&gt;&gt;s;
        if(s == "Push"){
            cin&gt;&gt;num;
            value.push_back(num);
            pre.push_back(index);
            st.push(index++);
        } else{
            in.push_back(st.top());
            st.pop();
        }
    }
    
    postorder(0,0,n-1);

    cout&lt;&lt;post[0];
    for (int i = 1; i &lt; n; ++i) {
        cout&lt;&lt;" "&lt;&lt;post[i];
    }
    return 0;
}
</code></pre>
<p>后序+中序推先序</p>
<p>同上。</p>
<h4 id="avl-平衡二叉树">AVL （平衡二叉树）</h4>
<h4 id="bst-二叉搜索树">BST（二叉搜索树）</h4>
<h2 id="图的基本算法">图的基本算法</h2>
<h4 id="保存方式">保存方式</h4>
<p>临界表</p>
<p>邻接矩阵</p>
<h4 id="基本算法">基本算法</h4>
<p>BFS</p>
<p>DFS</p>
<p>最短路径问题</p>
<p>​   单源最短路径问题 狄杰斯特拉算法</p>
<p>​   每次找到离该点最近的一个点，然后以这个点为定点继续拓展，最终得到从源点到其余各个顶点的最短路径。</p>
<p>​   eg：1003 Emergency (25分)</p>
<p>​   As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible.</p>
<p>​   Input Specification:</p>
<p>Each input file contains one test case. For each test case, the first line contains 4 positive integers: <em>N</em> (≤500) - the number of cities (and the cities are numbered from 0 to *N*−1), <em>M</em> - the number of roads, *C*1 and *C*2 - the cities that you are currently in and that you must save, respectively. The next line contains <em>N</em> integers, where the <em>i</em>-th integer is the number of rescue teams in the <em>i</em>-th city. Then <em>M</em> lines follow, each describes a road with three integers *c*1, *c*2 and <em>L</em>, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from *C*1 to *C*2.</p>
<p>​   Output Specification:</p>
<p>For each test case, print in one line two numbers: the number of different shortest paths between *C*1 and *C*2, and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.</p>
<p>​   Sample Input:</p>
<pre><code class="language-in">5 6 0 2
1 2 1 5 3
0 1 1
0 2 2
0 3 1
1 2 1
2 4 1
3 4 1
</code></pre>
<p>​   Sample Output:</p>
<pre><code class="language-out">2 4
</code></pre>
<p>​   典型的狄杰斯特拉问题，但是不一样的是在关注边权的前提下还需要对点权进行保存，在边权相等的情况下对点权进行比较。</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

int load[510][510],weight[510], dis[510],w[510],num[510];
bool visit[510];
const int inf = 99999999;


int main(){

    int n,m,c_0,c_1;
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;c_0&gt;&gt;c_1;
    for (int i = 0; i &lt; n; ++i) {
        cin&gt;&gt;weight[i];
    }
    int n_1,n_2;
    fill(load[0],load[0] + 510 * 510,inf);
    fill(dis,dis+510,inf);
    for (int j = 0; j &lt; m; ++j) {
        cin&gt;&gt;n_1&gt;&gt;n_2;
        cin&gt;&gt;load[n_1][n_2];
        load[n_2][n_1] = load[n_1][n_2];
    }

    dis[c_0] = 0;
    w[c_0] = weight[c_0];
    num[c_0] = 1;

    for (int i = 0; i &lt; n; i++) {
        int u = -1,minn = inf;
        for (int j = 0; j &lt; n; j++) {
            if(visit[j] == false &amp;&amp; dis[j] &lt; minn){
                u = j;
                minn = dis[j];
            }
        }
        if (u == -1) break;
        visit[u] = true;
        for (int v = 0; v &lt; n; v++) {
            if(visit[v]== false &amp;&amp; load[u][v] != inf){
                if(dis[u] + load[u][v] &lt; dis[v]){
                    dis[v] = dis[u] + load[u][v];
                    num[v] = num[u];
                    w[v] = w[u] + weight[v];
                } else if( dis[u] + load[u][v] == dis[v] ){
                    num[v] = num[v] + num[u];
                    if(w[u] + weight[v] &gt; w[v]){
                        w[v] = w[u]+weight[v];
                    }
                }
            }
        }
    }
    cout&lt;&lt;num[c_1]&lt;&lt;" "&lt;&lt;w[c_1];
    return 0;
}
</code></pre>
<p>​   全局最短路径问题 弗洛伊德算法</p>
<p>​</p>
</section>
</article>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'ngc7293s-blog'; 

     
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'https://ngc7293s-blog.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<footer id="footer">
<div id="social">
<a class="symbol" href="https://www.facebook.com/">
<i class="fa fa-facebook-square"></i>
</a>
<a class="symbol" href="https://www.github.com/ngc7292">
<i class="fa fa-github-square"></i>
</a>
<a class="symbol" href="https://www.twitter.com/">
<i class="fa fa-twitter-square"></i>
</a>
</div>
<p class="small">
    
       © Copyright 2020 <i aria-hidden="true" class="fa fa-heart"></i> ngc7293
    
    </p>
<p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
</p>
</footer>
</section>
<script src="https://ngc7292.github.io/js/jquery-2.2.4.min.js"></script>
<script src="https://ngc7292.github.io/js/main.js"></script>
<script src="https://ngc7292.github.io/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'ngc7293', 'auto');
ga('send', 'pageview');
</script>
</body>
</html>
