<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		 
			
  
    <meta name="twitter:card" content="summary"/>
    
      <meta name="twitter:image" content="https://ngc7292.github.io/images/avatar.png" />
    
  
  
  <meta name="twitter:title" content="leetcode array"/>
  <meta name="twitter:description" content="leetcode python by ngc7293"/>
  
    <meta name="twitter:site" content="@ngc7293"/>
  
  
  
  
    <meta name="twitter:creator" content="@ngc7293"/>
  



		
		<meta name="author" content="ngc7293">
		
		<meta name="generator" content="Hugo 0.36.1" />
		<title>leetcode array &middot; ngc7293&#39;s blog</title>
		<link rel="shortcut icon" href="https://ngc7292.github.io/images/favicon.ico">
		<link rel="stylesheet" href="https://ngc7292.github.io/css/style.css">
		<link rel="stylesheet" href="https://ngc7292.github.io/css/highlight.css">

		
		<link rel="stylesheet" href="https://ngc7292.github.io/css/font-awesome.min.css">
		

		
		<link href="https://ngc7292.github.io/index.xml" rel="alternate" type="application/rss+xml" title="ngc7293&#39;s blog" />
		

		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='https://ngc7292.github.io/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://ngc7292.github.io/posts'>Archive</a>
	<a href='https://ngc7292.github.io/tags'>Tags</a>
	<a href='https://ngc7292.github.io/about'>About</a>

	

	
	<a class="cta" href="https://ngc7292.github.io/index.xml">Subscribe</a>
	
</nav>


        <section id="wrapper" class="post">
            <article>
                <header>
                    <h1>
                        leetcode array
                    </h1>
                    <h2 class="headline">
                    Sep 28, 2018 00:00
                    · 1758 words
                    · 9 minute read
                      <span class="tags">
                      
                      
                          
                              <a href="https://ngc7292.github.io/tags/python">python</a>
                          
                              <a href="https://ngc7292.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                  
                    <div id="toc">
                      <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#717-1-bit-and-2-bit-characters">717. 1-bit and 2-bit Characters</a></li>
<li><a href="#695-max-area-of-island">695. Max Area of Island</a></li>
<li><a href="#714-best-time-to-buy-and-sell-stock-with-transaction-fee">714. Best Time to Buy and Sell Stock with Transaction Fee</a></li>
<li><a href="#713-subarray-product-less-than-k">713. Subarray Product Less Than K</a></li>
<li><a href="#714-best-time-to-buy-and-sell-stock-with-transaction-fee-1">714. Best Time to Buy and Sell Stock with Transaction Fee</a></li>
<li><a href="#565-array-nesting">565. Array Nesting</a></li>
<li><a href="#840-magic-squares-in-grid">840. Magic Squares In Grid</a></li>
<li><a href="#611-valid-triangle-number">611. Valid Triangle Number</a></li>
<li><a href="#605-can-place-flowers">605. Can Place Flowers</a></li>
<li><a href="#835-image-overlap">835. Image Overlap</a></li>
<li><a href="#581-shortest-unsorted-continuous-subarray">581. Shortest Unsorted Continuous Subarray</a></li>
<li><a href="#39-combination-sum">39. Combination Sum</a></li>
<li><a href="#769-max-chunks-to-make-sorted">769. Max Chunks To Make Sorted</a></li>
</ul></li>
</ul>
</nav>
                    </div>
                  
                
                <section id="post-body">
                    <p>leetcode problem of array.</p>

<p></p>

<h2 id="717-1-bit-and-2-bit-characters">717. 1-bit and 2-bit Characters</h2>

<p>We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11).</p>

<p>Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.</p>

<pre><code class="language-python">class Solution:
    def isOneBitCharacter(self, bits):
        &quot;&quot;&quot;
        :type bits: List[int]
        :rtype: bool
        &quot;&quot;&quot;
        i = 0
        res = [0 for i in bits]
        while i &lt; len(bits):
            if res[i] == 1 and i == len(bits)-1:
                return False
            elif res[i] == 1:
                i += 1
            elif bits[i] == 0:
                i += 1
            elif bits[i] == 1:
                res[i+1] = 1
                i += 1
        return True
</code></pre>

<h2 id="695-max-area-of-island">695. Max Area of Island</h2>

<p>Given a non-empty 2D array grid of 0&rsquo;s and 1&rsquo;s, an island is a group of 1&rsquo;s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p>

<p>Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)</p>

<pre><code class="language-python">class Solution:
    def maxAreaOfIsland(self, grid):
        &quot;&quot;&quot;
        :type grid: List[List[int]]
        :rtype: int
        &quot;&quot;&quot;
        self.grid = grid
        self.height = len(grid)
        self.width = len(grid[0])
        max_area = 0
        for x in range(self.height):
            for y in range(self.width):
                if self.grid[x][y] == 1:
                    max_area = max(max_area,self.dfs(x,y))
        return max_area
    
    def dfs(self,x,y):
        if x &lt; 0 or x &gt;= self.height or y &lt; 0 or y &gt;= self.width or self.grid[x][y] == 0:
            return 0
        area = 1
        self.grid[x][y] = 0
        area += self.dfs(x-1,y)+self.dfs(x,y-1)+self.dfs(x+1,y)+self.dfs(x,y+1)
        return area
</code></pre>

<h2 id="714-best-time-to-buy-and-sell-stock-with-transaction-fee">714. Best Time to Buy and Sell Stock with Transaction Fee</h2>

<p>Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee.</p>

<p>You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)</p>

<p>Return the maximum profit you can make.</p>

<pre><code class="language-python">class Solution:
    def maxProfit(self, prices, fee):
        &quot;&quot;&quot;
        :type prices: List[int]
        :type fee: int
        :rtype: int
        &quot;&quot;&quot;
        cash = 0
        hold = -prices[0]
        for i in prices:
            cash = max(cash,hold+i-fee)
            hold = max(hold,cash-i)
        return cash
</code></pre>

<h2 id="713-subarray-product-less-than-k">713. Subarray Product Less Than K</h2>

<p>Your are given an array of positive integers nums.</p>

<p>Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k.</p>

<pre><code class="language-python">class Solution:
    def numSubarrayProductLessThanK(self, nums, k):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type k: int
        :rtype: int
        &quot;&quot;&quot;
        if k &lt;= 1:
            return 0
        n = len(nums)
        p = 1
        i = 0
        res = 0
        for j in range(n):
            p *= nums[j]
            while p &gt;= k:
                p /= nums[i]
                i += 1
            res += j - i + 1
        return res
</code></pre>

<h2 id="714-best-time-to-buy-and-sell-stock-with-transaction-fee-1">714. Best Time to Buy and Sell Stock with Transaction Fee</h2>

<p>Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee.</p>

<p>You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)</p>

<p>Return the maximum profit you can make.</p>

<pre><code class="language-python">class Solution:
    def maxProfit(self, prices, fee):
        &quot;&quot;&quot;
        :type prices: List[int]
        :type fee: int
        :rtype: int
        &quot;&quot;&quot;
        cash = 0
        hold = -prices[0]
        for i in prices:
            cash = max(cash,hold+i-fee)
            hold = max(hold,cash-i)
        return cash
</code></pre>

<h2 id="565-array-nesting">565. Array Nesting</h2>

<p>A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], &hellip; } subjected to the rule below.</p>

<p>Suppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]… By that analogy, we stop adding right before a duplicate element occurs in S.</p>

<pre><code class="language-python">class Solution:
    def arrayNesting(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        count = 0
        res = {i:0 for i in range(len(nums))}
        for i in range(len(nums)):
            index = i
            cnt = 0
            if res[index] == 1:
                continue
            while index &lt; len(nums):
                if res[index] == 0:
                    res[index] = 1
                    index = nums[index]
                    cnt += 1
                else:
                    break
            count = max(count,cnt)
        return count
</code></pre>

<h2 id="840-magic-squares-in-grid">840. Magic Squares In Grid</h2>

<p>A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.</p>

<p>Given an grid of integers, how many 3 x 3 &ldquo;magic square&rdquo; subgrids are there?  (Each subgrid is contiguous).</p>

<pre><code class="language-python">class Solution:
    def numMagicSquaresInside(self, grid):
        &quot;&quot;&quot;
        :type grid: List[List[int]]
        :rtype: int
        &quot;&quot;&quot;
        height = len(grid)
        width = len(grid[0]) if height != 0 else 0
        if height &lt; 3 or width &lt; 3:
            return 0
        count = 0
        for i in range(height-2):
            for j in range(width-2):
                flag = 0
                matirx = []
                for m in range(i,i+3):
                    matirx_list = []
                    for n in range(j,j+3):
                        if grid[m][n] &gt;= 10 or grid[m][n] &lt;= 0:
                            flag = 1
                            break
                        matirx_list.append(grid[m][n])
                    matirx.append(matirx_list)
                    if flag == 1:
                        break
                if flag == 1:
                    continue
                print(matirx)
                if self.check(matirx):
                    count += 1
        return count
     
    def check(self,matirx):
        if matirx[1][1] != 5:
            return False
        num_t = sum(matirx[0])
        num_b = sum(matirx[2])
        num_m = sum(matirx[1])
        num_l = sum([matirx[i][0] for i in range(3)])
        num_r = sum([matirx[i][2] for i in rang
                     e(3)])
        if num_t == 15 and num_b == 15 and num_m == 15 and num_l == 15 and num_r == 15:
            return True
        else:
            return False
'''

## 746. Min Cost Climbing Stairs

On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).

Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.

```python
class Solution:
    def minCostClimbingStairs(self, cost):
        &quot;&quot;&quot;
        :type cost: List[int]
        :rtype: int
        &quot;&quot;&quot;
        res = [0,0]
        for i in range(2,len(cost)+1):
            res.append(min(res[i-1]+cost[i-1],res[i-2]+cost[i-2]))
        return res[-1]
</code></pre>

<h2 id="611-valid-triangle-number">611. Valid Triangle Number</h2>

<p>Given an array consists of non-negative integers, your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.</p>

<pre><code class="language-python">class Solution:
    def triangleNumber(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        nums.sort()
        res = 0
        for i in range(0,len(nums)-2):
            j = i+1
            for k in range(i+2,len(nums)):
                while j&lt;k and nums[i] + nums[j] &lt;= nums[k]:
                    j += 1
                res += k-j
        return res
</code></pre>

<h2 id="605-can-place-flowers">605. Can Place Flowers</h2>

<p>Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die.</p>

<p>Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule.</p>

<pre><code class="language-python">class Solution:
    def canPlaceFlowers(self, flowerbed, n):
        &quot;&quot;&quot;
        :type flowerbed: List[int]
        :type n: int
        :rtype: bool
        &quot;&quot;&quot;
        count = 1
        result = 0
        for i in range(len(flowerbed)):
            if flowerbed[i] == 0:
                count += 1
            else:
                result += (count-1)//2
                count = 0
        if count != 0:
            result += count/2
        return result&gt;=n
</code></pre>

<h2 id="835-image-overlap">835. Image Overlap</h2>

<p>Two images A and B are given, represented as binary, square matrices of the same size.  (A binary matrix has only 0s and 1s as values.)</p>

<p>We translate one image however we choose (sliding it left, right, up, or down any number of units), and place it on top of the other image.  After, the overlap of this translation is the number of positions that have a 1 in both images.</p>

<p>(Note also that a translation does not include any kind of rotation.)</p>

<p>What is the largest possible overlap?</p>

<pre><code class="language-python">class Solution:
    def largestOverlap(self, A, B):
        &quot;&quot;&quot;
        :type A: List[List[int]]
        :type B: List[List[int]]
        :rtype: int
        &quot;&quot;&quot;
        N = len(A)
        LA = [(i,j) for i in range(N) for j in range(N) if A[i][j]]
        LB = [(i,j) for i in range(N) for j in range(N) if B[i][j]]
        res = collections.Counter([(x1-x2,y1-y2) for (x1,y1) in LA for (x2,y2) in LB])
        return max(res.values() or [0])
</code></pre>

<h2 id="581-shortest-unsorted-continuous-subarray">581. Shortest Unsorted Continuous Subarray</h2>

<p>Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too.</p>

<p>You need to find the shortest such subarray and output its length.</p>

<pre><code class="language-python">class Solution:
    def findUnsortedSubarray(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        start = -1
        end = -1
        tmp = nums.copy()
        tmp.sort()
        for i in range(len(nums)):
            if nums[i] != tmp[i]:
                if start == -1:
                    start = i
                else:
                    end = i
        return end-start+1 if end != start else 0
</code></pre>

<h2 id="39-combination-sum">39. Combination Sum</h2>

<p>Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.</p>

<p>The same repeated number may be chosen from candidates unlimited number of times.</p>

<p>彩笔ngc日常抄代码，<a href="https://blog.csdn.net/happyaaaaaaaaaaa/article/details/50897809">https://blog.csdn.net/happyaaaaaaaaaaa/article/details/50897809</a></p>

<p>原本是想用回溯法，但是出现了很大的问题，在2，2，2，3之后会陷入无限循环，需要给他一个位来判断是否加过这个值，我就没有再做下去，然后，在csdn发现了这位老哥的做法，真的是超级棒了</p>

<pre><code class="language-python">class Solution(object):
    def combinationSum(self, candidates, target):
        &quot;&quot;&quot;
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        &quot;&quot;&quot;
        candidates = sorted(candidates)
        res = [] 
        stack = [(0,[],target)]
        length = len(candidates)
        while stack:
            i, temp, tar=stack.pop()
            while i&lt;length and tar&gt;0:
                if candidates[i]==tar: 
                    res.append(temp+[candidates[i]])
                stack += (i, temp+[candidates[i]], tar-candidates[i]),
                i+=1
        return res
</code></pre>

<p>ps：不过好像效率不是特别的高，还有一个递归版本的，效率高很多</p>

<pre><code class="language-python">class Solution:
    def combinationSum(self, candidates, target):
        &quot;&quot;&quot;
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        &quot;&quot;&quot;
        candidates.sort()
        res = []
        size = len(candidates)
        def helper(i, left, cur):
            if left == 0:
                res.append(cur)
                return
            for j in range(i, size):
                if left &lt; candidates[j]:
                    break
                helper(j, left - candidates[j], cur + [candidates[j]])
        helper(0, target, [])
        return res
</code></pre>

<p>日常学习。</p>

<h2 id="769-max-chunks-to-make-sorted">769. Max Chunks To Make Sorted</h2>

<p>Given an array arr that is a permutation of [0, 1, &hellip;, arr.length - 1], we split the array into some number of &ldquo;chunks&rdquo; (partitions), and individually sort each chunk.  After concatenating them, the result equals the sorted array.</p>

<p>What is the most number of chunks we could have made?</p>

<pre><code class="language-python">class Solution:
    def maxChunksToSorted(self, arr):
        &quot;&quot;&quot;
        :type arr: List[int]
        :rtype: int
        &quot;&quot;&quot;
        res = 0
        max_num = 0
        for i in range(len(arr)):
            max_num = max(max_num,arr[i])
            if max_num == i:
                res += 1
        return res
</code></pre>
                </section>
            </article>

            
                <a class="twitter" href="https://twitter.com/intent/tweet?text=https%3a%2f%2fngc7292.github.io%2fposts%2fleetcode_array%2f - leetcode_python%20array by @ngc7293"><span class="icon-twitter"> tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>

            

            
                <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'ngc7293s-blog'; 

     
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'https://ngc7293s-blog.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
            

            

            <footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="https://www.facebook.com/">
        <i class="fa fa-facebook-square"></i>
    </a>
    
    <a class="symbol" href="https://www.github.com/ngc7292">
        <i class="fa fa-github-square"></i>
    </a>
    
    <a class="symbol" href="https://www.twitter.com/">
        <i class="fa fa-twitter-square"></i>
    </a>
    


</div>

    
    <p class="small">
    
       © Copyright 2018 <i class="fa fa-heart" aria-hidden="true"></i> ngc7293
    
    </p>
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
</footer>

        </section>

        <script src="https://ngc7292.github.io/js/jquery-2.2.4.min.js"></script>
<script src="https://ngc7292.github.io/js/main.js"></script>
<script src="https://ngc7292.github.io/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>




  
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'ngc7293', 'auto');
ga('send', 'pageview');
</script>





    </body>
</html>
